# [二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

方法一：分治法

```js
var minDepth = function (root) {
    if (root === null) {
        return 0
    }
    let left = minDepth(root.left) // 左边最小深度
    let right = minDepth(root.right) // 右边最小深度

    // 总体最小深度和总体最小深度有什么关系？
    // return Math.min(left, right) + 1 // 为什么这里直接返回不对？case2 里面有一边最小值一直是0
    if (left === 0) {
        // 左子树啥都没有，此时最小高度依赖右子树
        return right + 1
    } else if (right === 0) {
        // 右子树是空，最小高度依赖左子树
        return left + 1
    } else {
        return Math.min(left, right) + 1
    }
};
```

## 方法二：遍历

```js
var minDepth = function (root) {
    let dept = Number.MAX_SAFE_INTEGER
    if(root === null){
        return 0
    }

    function helper(root, currentDept) {
        if (root === null) {
            return
        }
        // 最小深度什么时候更新？
        if (root.left === null && root.right === null && currentDept < dept) {
            // 到达了叶子节点才更新，也就是没有左右子树
            dept = currentDept
        }
        helper(root.left, currentDept + 1)
        helper(root.right, currentDept + 1)
    }

    helper(root, 1)

    return dept
};
```

